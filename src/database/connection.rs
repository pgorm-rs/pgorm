use std::{future::Future, ops::AsyncFn, pin::Pin};

use crate::DbErr;
use tokio_postgres::{
    types::{BorrowToSql, ToSql},
    Row, ToStatement,
};

use super::DatabaseTransaction;

/// The generic API for a database connection that can perform query or execute statements.
/// It abstracts database connection and transaction
#[async_trait::async_trait]
pub trait ConnectionTrait: Sync {
    /// Execute a [Statement]
    async fn execute<T>(&self, statement: &T, params: &[&(dyn ToSql + Sync)]) -> Result<u64, DbErr>
    where
        T: ?Sized + ToStatement + Send + Sync;

    /// Execute a unprepared [Statement]
    async fn execute_raw<T, P, I>(&self, statement: &T, params: I) -> Result<u64, DbErr>
    where
        T: ?Sized + ToStatement + Send + Sync,
        P: BorrowToSql,
        I: IntoIterator<Item = P> + Send,
        I::IntoIter: ExactSizeIterator;

    async fn query_one<T>(
        &self,
        statement: &T,
        params: &[&(dyn ToSql + Sync)],
    ) -> Result<Row, DbErr>
    where
        T: ?Sized + ToStatement + Send + Sync;

    async fn query_opt<T>(
        &self,
        statement: &T,
        params: &[&(dyn ToSql + Sync)],
    ) -> Result<Option<Row>, DbErr>
    where
        T: ?Sized + ToStatement + Send + Sync;

    async fn query_all<T>(
        &self,
        statement: &T,
        params: &[&(dyn ToSql + Sync)],
    ) -> Result<Vec<Row>, DbErr>
    where
        T: ?Sized + ToStatement + Send + Sync;

    // async fn transaction(
    //     &self,
    //     closure: for<'a> fn(&mut DatabaseTransaction<'a>) -> Pin<Box<dyn Future<Output = Result<(), DbErr>> + Send>>,
    // ) -> Result<(), DbErr>;

    // async fn query_raw<T, P, I>(&self, statement: &T, params: I) -> Result<RowStream, DbErr>
    // where
    //     T: ?Sized + ToStatement,
    //     P: BorrowToSql,
    //     I: IntoIterator<Item = P>,
    //     I::IntoIter: ExactSizeIterator;
}

/// Spawn database transaction
#[async_trait::async_trait(?Send)]
pub trait TransactionTrait {
    // fn transaction(
    //     &mut self,
    //     closure: for<'a> fn(
    //         &mut DatabaseTransaction<'a>,
    //     ) -> Pin<Box<dyn Future<Output = Result<(), DbErr>> + Send>>,
    // ) -> impl Future<Output = Result<(), DbErr>>;
    async fn transaction<T, F: AsyncFn(&mut DatabaseTransaction<'_>) -> Result<T, DbErr>>(
        &mut self,
        closure: F,
    ) -> Result<T, DbErr>;

    // /// Execute SQL `BEGIN` transaction with isolation level and/or access mode.
    // /// Returns a Transaction that can be committed or rolled back
    // async fn begin_with_config(
    //     &mut self,
    //     read_only: bool,
    //     isolation_level: Option<tokio_postgres::IsolationLevel>,
    // ) -> Result<DatabaseTransaction<'_>, DbErr>;

    // Execute the function inside a transaction.
    // If the function returns an error, the transaction will be rolled back. If it does not return an error, the transaction will be committed.
    // async fn transaction<F, T, E>(&self, callback: F) -> Result<T, TransactionError<E>>
    // where
    //     F: for<'c> FnOnce(
    //             &'c DatabaseTransaction,
    //         ) -> Pin<Box<dyn Future<Output = Result<T, E>> + Send + 'c>>
    //         + Send,
    //     T: Send,
    //     E: std::error::Error + Send;

    // /// Execute the function inside a transaction with isolation level and/or access mode.
    // /// If the function returns an error, the transaction will be rolled back. If it does not return an error, the transaction will be committed.
    // async fn transaction_with_config<F, T, E>(
    //     &self,
    //     callback: F,
    //     isolation_level: Option<IsolationLevel>,
    //     access_mode: Option<AccessMode>,
    // ) -> Result<T, TransactionError<E>>
    // where
    //     F: for<'c> FnOnce(
    //             &'c DatabaseTransaction,
    //         ) -> Pin<Box<dyn Future<Output = Result<T, E>> + Send + 'c>>
    //         + Send,
    //     T: Send,
    //     E: std::error::Error + Send;
}
